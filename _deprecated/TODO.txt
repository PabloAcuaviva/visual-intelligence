# TODO:
Right now the tasks (game_of_life, maze, path_navigation) which are generated share a lot of structure, but nevertheless
have a lot of logic duplicated. We probably need a Task super class and a TaskDatasetGenerator superclass to abstract quite a bit
of this logic away so that it is easier to mantain and expand the codebase.
################################
Some additional tasks which may be interesting to look into:

üß† Brian‚Äôs Brain
The rules are:
Each cell in a 2D grid is in one of three states: on, dying, or off. At each time step:

If a cell is off and exactly two of its 8 neighbors are on, it becomes on.

If a cell is on, it becomes dying.

If a cell is dying, it becomes off.

This creates self-propagating wavefronts and chaotic patterns resembling neural activity or fire.

‚ö° Wireworld
The rules are:
Each cell in a 2D grid is in one of four states: empty, electron head, electron tail, or conductor. At each time step:

An electron head becomes an electron tail.

An electron tail becomes a conductor.

A conductor becomes an electron head if exactly 1 or 2 of its neighbors are electron heads.

All other cells remain in their current state.

Wireworld is often used to simulate logic circuits and signal propagation.

üêú Turmites
The rules are:
A turmite is an agent moving on a 2D grid. The grid consists of discrete cell states, and the turmite has its own internal state. At each step, the turmite:

Reads the current cell state and its own internal state.

Uses a rule table to determine:

The direction to turn (left, right, straight, or 180¬∞).

The new state to write to the current cell.

The new internal state of the turmite.

Updates the cell and its own state.

Moves forward one cell in the new direction.

The behavior depends entirely on the rule table and can result in highly complex patterns. Langton‚Äôs Ant is a special case with 1 internal state and 2 cell states.
